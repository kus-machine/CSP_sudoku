import numpy as np
import doctest

#функция вывода на экран матрицы 9 на 9
def show(a):
	a=a.tolist()
	for i in range(9):
		for j in range(9):
			if(a[i][j]==0):
				a[i][j]=' '
	for i in range(len(a)):
		if(i==0):
			print("<----------------------->")
		if(i%3==0 and i!=0):
			print("|-------|-------|-------|")
		print("|",a[i][0],a[i][1],a[i][2],"|",a[i][3],a[i][4],a[i][5],"|",a[i][6],a[i][7],a[i][8],"|")
	print("<----------------------->\n")

#функция соседства, выдает матрицу, еденицы в которой - соседи с элементом i,j
def neighbor(i,j):
	'''
	функция соседства, выдает матрицу, еденицы в которой - соседи с элементом i,j
	>>> neighbor(0,0)
	array([[1, 1, 1, 1, 1, 1, 1, 1, 1],
	       [1, 1, 1, 0, 0, 0, 0, 0, 0],
	       [1, 1, 1, 0, 0, 0, 0, 0, 0],
	       [1, 0, 0, 0, 0, 0, 0, 0, 0],
	       [1, 0, 0, 0, 0, 0, 0, 0, 0],
	       [1, 0, 0, 0, 0, 0, 0, 0, 0],
	       [1, 0, 0, 0, 0, 0, 0, 0, 0],
	       [1, 0, 0, 0, 0, 0, 0, 0, 0],
	       [1, 0, 0, 0, 0, 0, 0, 0, 0]])
	'''
	a=np.zeros((9,9),int)
	for k in range(9):
		for l in range(9):
			if(k==i or l==j):
				a[k][l]=1
	if(i%3==0 and j%3==0):
		a[i][j]=a[i][j+1]=a[i][j+2]=a[i+1][j]=a[i+1][j+1]=a[i+1][j+2]=a[i+2][j]=a[i+2][j+1]=a[i+2][j+2]=1
	if(i%3==0 and j%3==1):
		a[i][j]=a[i][j+1]=a[i][j-1]=a[i+1][j]=a[i+1][j+1]=a[i+1][j-1]=a[i+2][j]=a[i+2][j+1]=a[i+2][j-1]=1
	if(i%3==0 and j%3==2):
		a[i][j]=a[i][j-1]=a[i][j-2]=a[i+1][j]=a[i+1][j-1]=a[i+1][j-2]=a[i+2][j]=a[i+2][j-1]=a[i+2][j-2]=1
	if(i%3==1 and j%3==0):
		a[i][j]=a[i][j+1]=a[i][j+2]=a[i+1][j]=a[i+1][j+1]=a[i+1][j+2]=a[i-1][j]=a[i-1][j+1]=a[i-1][j+2]=1
	if(i%3==1 and j%3==1):
		a[i][j]=a[i][j+1]=a[i][j-1]=a[i+1][j]=a[i+1][j+1]=a[i+1][j-1]=a[i-1][j]=a[i-1][j+1]=a[i-1][j-1]=1
	if(i%3==1 and j%3==2):
		a[i][j]=a[i][j-1]=a[i][j-2]=a[i-1][j]=a[i-1][j-1]=a[i-1][j-2]=a[i+1][j]=a[i+1][j-1]=a[i+1][j-2]=1
	if(i%3==2 and j%3==0):
		a[i][j]=a[i][j+1]=a[i][j+2]=a[i-2][j]=a[i-2][j+1]=a[i-2][j+2]=a[i-1][j]=a[i-1][j+1]=a[i-1][j+2]=1
	if(i%3==2 and j%3==1):
		a[i][j]=a[i][j+1]=a[i][j-1]=a[i-2][j]=a[i-2][j+1]=a[i-2][j-1]=a[i-1][j]=a[i-1][j+1]=a[i-1][j-1]=1
	if(i%3==2 and j%3==2):
		a[i][j]=a[i][j-1]=a[i][j-2]=a[i-1][j]=a[i-1][j-1]=a[i-1][j-2]=a[i-2][j]=a[i-2][j-1]=a[i-2][j-2]=1
	return a

#функция проверяет, нет ли ошибок в условии (повторения среди соседей)
def check(board):
	'''
	>>> check(np.array([[4,4,6,8,1,9,5,7,3],[9,8,0,5,7,4,2,1,6],[5,1,7,2,3,6,4,8,9],[1,5,8,3,0,0,9,6,7],[7,4,2,9,6,8,1,3,5],[3,6,9,7,5,1,8,4,2],[2,0,4,6,8,5,3,9,1],[8,3,5,1,9,7,6,2,4],[6,9,1,4,2,3,7,5,0]]))
	BAD BOARD
	True
	>>> check(np.array([[4,2,6,8,1,9,5,7,3],[9,8,0,5,7,4,2,1,6],[5,1,7,2,3,6,4,8,9],[1,5,8,3,0,0,9,6,7],[7,4,2,9,6,8,1,3,5],[3,6,9,7,5,1,8,4,2],[2,0,4,6,8,5,3,9,1],[8,3,5,1,9,7,6,2,4],[6,9,1,4,2,3,7,5,0]]))
	False
	'''
	bad=False
	for i in range(9):
		for j in range(9):
			if(board[i][j]<0 or board[i][j]>9):
				bad=True
			sosedi=neighbor(i,j)
			for i1 in range(9):
				for j1 in range(9):
					if(sosedi[i1][j1]==1 and board[i1][j1]!=0):
						if(i!=i1 or j!=j1):
							if(board[i][j]==board[i1][j1]):
								bad=True
	if(bad):
		print("BAD BOARD")
	return bad

#функция обновляет функции g & q
def update_q(board,q):
	'''
	>>> q=np.ones((9,9,9),int)
	>>> board=np.array([[4,2,6,8,1,9,5,7,3],[9,8,0,5,7,4,2,1,6],[5,1,7,2,3,6,4,8,9],[1,5,8,3,0,0,9,6,7],[7,4,2,9,6,8,1,3,5],[3,6,9,7,5,1,8,4,2],[2,0,4,6,8,5,3,9,1],[8,3,5,1,9,7,6,2,4],[6,9,1,4,2,3,7,5,0]])
	>>> update_q(board,q)
	array([[[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0]],
	<BLANKLINE>
	       [[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 1, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0]],
	<BLANKLINE>
	       [[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0]],
	<BLANKLINE>
	       [[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 1, 0, 0, 0, 0, 0],
		[0, 1, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0]],
	<BLANKLINE>
	       [[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0]],
	<BLANKLINE>
	       [[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0]],
	<BLANKLINE>
	       [[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 1, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0]],
	<BLANKLINE>
	       [[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0]],
	<BLANKLINE>
	       [[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 1, 0]]])

	'''
	#все qt(k) где k - заполнено - ставим в 0 (кроме заполненного)
	for i in range(9):
		for j in range(9):
			if(board[i][j]!=0):
				for l in range(9):
					if(board[i][j]-1!=l):
						q[i][j][l]=0
	#фиксируем элемент с доски
	for i1 in range(9):
		for j1 in range(9):
			#находим для него всех соседей
			sosed=neighbor(i1,j1)
			#проходимся по всем незаполненным соседям для фиксированого выше элемента и деактивируем у них метки с числом как у фиксированного выше элемента
			if(board[i1][j1]!=0):
				for i2 in range(9):
					for j2 in range(9):
						if(sosed[i2][j2]==1 and board[i2][j2]==0):
							for k1 in range(9):
								q[i2][j2][board[i1][j1]-1]=0
	return q
#функция решения
def solve(board):
	'''
	правильное условие
	>>> solve(np.array([[4,2,6,8,1,9,5,7,3],[9,8,3,5,7,4,2,1,6],[5,1,7,2,3,6,4,8,9],[1,5,8,3,4,2,9,6,7],[7,4,2,9,6,8,1,3,5],[3,6,9,7,5,1,8,4,2],[2,7,4,6,8,5,3,9,1],[8,3,5,1,9,7,6,2,4],[6,9,1,4,2,3,7,5,0]]))
	<----------------------->
	| 4 2 6 | 8 1 9 | 5 7 3 |
	| 9 8 3 | 5 7 4 | 2 1 6 |
	| 5 1 7 | 2 3 6 | 4 8 9 |
	|-------|-------|-------|
	| 1 5 8 | 3 4 2 | 9 6 7 |
	| 7 4 2 | 9 6 8 | 1 3 5 |
	| 3 6 9 | 7 5 1 | 8 4 2 |
	|-------|-------|-------|
	| 2 7 4 | 6 8 5 | 3 9 1 |
	| 8 3 5 | 1 9 7 | 6 2 4 |
	| 6 9 1 | 4 2 3 | 7 5   |
	<----------------------->
	<BLANKLINE>
	ITERATION  1
	<----------------------->
	| 4 2 6 | 8 1 9 | 5 7 3 |
	| 9 8 3 | 5 7 4 | 2 1 6 |
	| 5 1 7 | 2 3 6 | 4 8 9 |
	|-------|-------|-------|
	| 1 5 8 | 3 4 2 | 9 6 7 |
	| 7 4 2 | 9 6 8 | 1 3 5 |
	| 3 6 9 | 7 5 1 | 8 4 2 |
	|-------|-------|-------|
	| 2 7 4 | 6 8 5 | 3 9 1 |
	| 8 3 5 | 1 9 7 | 6 2 4 |
	| 6 9 1 | 4 2 3 | 7 5 8 |
	<----------------------->
	<BLANKLINE>
	ITERATION  2
	<----------------------->
	| 4 2 6 | 8 1 9 | 5 7 3 |
	| 9 8 3 | 5 7 4 | 2 1 6 |
	| 5 1 7 | 2 3 6 | 4 8 9 |
	|-------|-------|-------|
	| 1 5 8 | 3 4 2 | 9 6 7 |
	| 7 4 2 | 9 6 8 | 1 3 5 |
	| 3 6 9 | 7 5 1 | 8 4 2 |
	|-------|-------|-------|
	| 2 7 4 | 6 8 5 | 3 9 1 |
	| 8 3 5 | 1 9 7 | 6 2 4 |
	| 6 9 1 | 4 2 3 | 7 5 8 |
	<----------------------->
	<BLANKLINE>
	q(2)=q(1)
	array([[4, 2, 6, 8, 1, 9, 5, 7, 3],
	       [9, 8, 3, 5, 7, 4, 2, 1, 6],
	       [5, 1, 7, 2, 3, 6, 4, 8, 9],
	       [1, 5, 8, 3, 4, 2, 9, 6, 7],
	       [7, 4, 2, 9, 6, 8, 1, 3, 5],
	       [3, 6, 9, 7, 5, 1, 8, 4, 2],
	       [2, 7, 4, 6, 8, 5, 3, 9, 1],
	       [8, 3, 5, 1, 9, 7, 6, 2, 4],
	       [6, 9, 1, 4, 2, 3, 7, 5, 8]])
	
	неправильное условие:
	>>> solve(np.array([[4,4,6,8,1,9,5,7,3],[9,8,3,5,7,4,2,1,6],[5,1,7,2,3,6,4,8,9],[1,5,8,3,4,2,9,6,7],[7,4,2,9,6,8,1,3,5],[3,6,9,7,5,1,8,4,2],[2,7,4,6,8,5,3,9,1],[8,3,5,1,9,7,6,2,4],[6,9,1,4,2,3,7,5,0]]))
	BAD BOARD
	array([[4, 4, 6, 8, 1, 9, 5, 7, 3],
	       [9, 8, 3, 5, 7, 4, 2, 1, 6],
	       [5, 1, 7, 2, 3, 6, 4, 8, 9],
	       [1, 5, 8, 3, 4, 2, 9, 6, 7],
	       [7, 4, 2, 9, 6, 8, 1, 3, 5],
	       [3, 6, 9, 7, 5, 1, 8, 4, 2],
	       [2, 7, 4, 6, 8, 5, 3, 9, 1],
	       [8, 3, 5, 1, 9, 7, 6, 2, 4],
	       [6, 9, 1, 4, 2, 3, 7, 5, 0]])
	'''
	if(not check(board)):
		q=np.ones((9,9,9),int)
		show(board)
		q=update_q(board,q)
		it=0

		while(True):
			#костыль, в одну строку нельзя "запомнить" последний массив и чтобы не было выхода из цикла
			q1=q+1
			q2=q1-1
			for i in range(9):
				for j in range(9):
					if(q[i][j].sum()==1):
						board[i][j]=int(np.nonzero(q[i][j])[0])+1
						q[i][j]=0
			it+=1
			print("ITERATION ",it)
			show(board)
			q=update_q(board,q)
			if(np.array_equal(q2,q)):
				print("q({0})=q({1})".format(it,it-1))
				if(np.count_nonzero(board)<81):
					print("однозначное решение не найдено")
				break
	return board
#doctest.testmod()